# 线程和进程
- Oracle 的理解
    - 进程：使用fork系统调用创建的UNIX环境，就是一个运行程序
    - 线程：在进程上下文中执行的一系列指令
    
- 进程：process，指的是程序的一次执行，在用户下达运行程序的命令后，就会产生进程。
就是程序的真正运行的实例，是资源分配的单位
- 线程：是CPU的基本调度单位，每个线程执行的都是进程代码的某个片段

- 进程和线程的关系
    - 操作系统中有很多进程，每个进程中可以有一个或多个线程
    
- 进程和线程的不同
    - 起源不同：先有进程后有线程，线程的出现是为了提高执行效率
    - 概念不同：进程具有独立功能的一个程序运行产生的实例，是操作系统分配资源的基本单位
    而线程是CPU调用的基本单位
    - 内存共享方式：不同进程之间的内存是不共享的，如果非得共享，就需要进程通信IPC，
    线程可以有一定的共享内存
    - 拥有的资源不同：线程拥有的资源少于进程，
        - 线程共享的内容包含
            - 进程的代码片段
            - 信号量
            - 进程ID等
        - 线程独有的内容包含
            - 线程ID
            - 寄存器组的值
            - 线程的堆栈
            - 错误返回码
            
    - 数量不同
    - 开销不同
        - 线程的创建、终止时间比较短
        - 同一个进程内的线程切换时间比进程切换短
        - 同一进程的各个线程见共享内存和文件资源，可以不通过内核进行通信
    - 相似点：生命周期
    
    
- java 和多线程的关系
    - 设计之初就支持多线程
    - java 的定位是服务端开发
    - 一对一映射到操作系统的内核线程
    - JVM自动启动的线程
        - Signal Dispatcher 把操作系统发来的信号分发给适当的处理器程序
        - Finalizer 负责对象的finalizer方法
        - Reference Handler 和GC、引用相关的线程
        - main 主线程，用户程序入口
        
        
# 多线程
- 什么是多线程
    如果一个程序允许两个或以上的线程，那么它就是多线程程序，多线程是指在单个进程中运行的多个线程
- 为什么需要多线程
    - 提供CPU的利用率
    - 可以避免无效等待（IO操作的时候）
    - 提供用户体验
    - 便于编程建模
    - 计算机定律：
        摩尔定律：CPU的主频一直在指数级别提高，目前的摩尔定律基本失效，CPU基本在4MHZ左右
        阿姆达尔定律：处理器越多，程序执行就越快，但有上线，取决于程序中串行部分的比例，比例越高，多处理器的效果越明显
- 什么场景会用到多线程
    - 执行耗时任务：IO操作，网络任务【新开线程操作】
    - tomcat、nio、并行下载
    - 需要大的并发量的时候
- 多线程的局限
    - 线程切换会带来额外的消耗
    - 异构化的任务（任务结构不一样）很难高效并行
    - 带来线程安全问题
        - 数据安全
        - 线程饥饿
        - 线程死锁
        
# 串行、并行、并发
## 串行和并行
- 串行：排队一个个执行
- 并行：线程一起执行
## 并行和并发
- 并发：
    - 只有一个处理器也可以实现
    - 逻辑上的同时运行
- 并行：
    - 多个处理器
    - 物理上的同时运行
    
- 并发的2中概念
    - 多个任务的执行状态
    - 对并发性的简称
        - 不同部分可以无序或同时执行，且不影响最终的执行结果
        
        
- 是什么让并发和并行成为可能
    - CPU的升级
    - 操作系统升级
    - 编程语言的升级
    
# 高并发
## 什么是高并发
- 大量的请求到达服务器的结果
## 高并发和多线程
- 多线程是解决高并发的一种方案，是解决高并发带来的线程安全问题和性能问题
- 也可以不通过多线程来解决，比如访问数据库问题，可以在数据库之上添加redis缓存
- 高并发不意味着是多线程：Redis
## 高并发有那些指标
- QPS（Queries Per Second）每秒查询数，每秒请求数
- 带宽
- PV（page View）一天的访问量
- UV（Unique Visitor）用户访问量
- IP和UV的区别
    - IP不同但是UV相同
    - UV不同但是IP相同
- 并发连接数
- 服务器平均请求等待时间

# 同步异步、阻塞与非阻塞
## 同步和异步
- 被调用者**是否主动**告诉调用者结果
- 同步：服务器的行为，而不是请求方的行为，在没有得到结果之前，服务端不返回任何结果
- 异步：调用在发出之后，服务短会立刻返回，告诉对方我收到你的请求了，我会处理的
## 阻塞和非阻塞
- 我是调用者，我调用一个东西之后，结果返回之前，是否还能做别的事
- 站在线程的角度
- 线程发出请求的角度

## 组合
- 同步阻塞
- 同步非阻塞
- 异步阻塞
- 异步非阻塞

# 常见面试问题
- 进程和线程的相同和不同

- 并行和并发不同

- 高并发是不是意味着多线程，有什么反例

- 多线程可以提高程序的执行效率，你知不知道有那些弊端

- 同步和异步，阻塞和非阻塞

- 单核CPU运行多线程程序有意义吗？
    有意义
    
    
# Synchronized 关键字
## Synchronized 简介
- 作用
    - 简单的防止线程干扰和内存不一致的问题，
      能够保证在同一时刻，只有一个线程在执行这段代码，达到并发安全的效果
- 定位
    - java的关键字
    - 最基本的互斥手段
    - 并发编程最先使用的处理线程安全的方式
- coding
    - 如果不使用并发手段的后果,消失的i++
        - i++操作
            - 读取i
            - 将i加1
            - 将i的值写入到内存中
            
## Synchronized的使用方式
- 对象锁
    - 方法锁，锁对象为this
    - 同步代码块 手动指定锁对象 this / 自定义object
- 类锁
    - 静态方法加锁，默认为当前类的对象
    - 代码块加锁，锁对象为class对象的时候
    
    
# 多线程访问同步方法的7种情况（面试常考）
- 两个线程同时访问一个对象的同步方法
    - 同一把锁可以实现同步
- 两个线程访问的是两个对象的同步方法
    - 锁对象不同不能实现同步
- 两个线程访问的是同步的静态方法
    - 锁对象为对象的class对象，可以实现同步
- 同时访问同步和非同步的方法
    - 非同步方法不受到影响
- 访问同一个对象的不同的普通同步方法
    - 可以实现同步，锁对象都是this
- 同时访问静态的同步和非静态的同步方法
    - 不能实现同步，锁对象不同
- 方法抛出异常后，会释放锁吗
    - 会释放锁


# synchronized 的性质
- 可重入
    - 可重入：指的是同一线程的外层函数获得锁之后，内层函数可以直接再次获取该锁，也叫递归锁
    - 可避免死锁，提升封装性
    - 粒度：线程而非调用
        
- 不可中断
    
    




    
